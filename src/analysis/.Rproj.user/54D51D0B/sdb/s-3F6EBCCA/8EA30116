{
    "collab_server" : "",
    "contents" : "################################################\n#      Introducción a la Ciencia de Datos      #\n#               REGRESIÓN LINEAR               #\n#                                              #\n# (C) Cristian González Guerrero               #\n################################################\n\n# Build the workspace\nsource(\"../regression/build-workspace.R\")\n\n\n# Get simple linear regression models\nsimple.linear.fit = list()\nfor (i in 1:(length(abalone)-1)) {\n  simple.linear.fit[[i]] = lm(abalone$Rings~abalone[,i])  \n  names(simple.linear.fit)[i] = names(abalone)[i]\n}\n\nsummary(simple.linear.fit$Sex)\nsummary(simple.linear.fit$Length)\nsummary(simple.linear.fit$Diameter)\nsummary(simple.linear.fit$Height)\nsummary(simple.linear.fit$Whole_weight)\nsummary(simple.linear.fit$Shucked_weight)\nsummary(simple.linear.fit$Viscera_weight)\nsummary(simple.linear.fit$Shell_weight)\n\n\nMSE = matrix(nrow = 8, ncol = 2)\ncolnames(MSE) = c(\"train\", \"test\")\nrownames(MSE) = names(abalone)[1:8]\nfor (tt in colnames(MSE)) {\n  for (i in rownames(MSE)) {\n    MSE[i, tt] = mean(sapply(\n      1:5, \n      run_lm_fold, \n      model = Rings~eval(parse(text = i)), \n      tt = tt\n    ))\n  }\n}\n\n# Using the shell weight seems to be the best model, since it produces less error.\n\n# Scatterplots\nmyData = melt.data.frame(\n  abalone[abalone$Height<0.3,],\n  id.vars=c(\"Sex\", \"Rings\")\n)\nmyData[myData$variable==\"Height\",] =\n  within(myData[myData$variable==\"Height\",], {\n    value = jitter(value, factor = 3)\n  }\n  )\nggplot(myData, aes(x = value, y = Rings)) + \n  geom_jitter(alpha = 0.03) + \n  geom_smooth(method = lm) + \n  facet_wrap( ~ variable, ncol = 2, scales = \"free\") + \n  xlab(\"\")\n\n\n# Analysis of preprocessing\nabalone = add.non.linearities(abalone)\nabalone.tra = lapply(abalone.tra, add.non.linearities)\nabalone.tst = lapply(abalone.tst, add.non.linearities)\n\n\n## Calculate correlations\nY.vars = grepl(\"Rings\", names(abalone))\nX.vars = grepl(\"_weight\", names(abalone))\ncor.Shucked_weight = cor(\n  subset(abalone, select = X.vars),\n  subset(abalone, select = Y.vars)\n)\n\n## New models, based on new variables\nsimple.linear.fit = list()\nfor (i in 1:(length(abalone))) {\n  simple.linear.fit[[i]] = lm(abalone$Rings~abalone[,i])  \n  names(simple.linear.fit)[i] = names(abalone)[i]\n}\n\nsummary(simple.linear.fit$Whole_weight.log)\nsummary(simple.linear.fit$Shucked_weight.2)\nsummary(simple.linear.fit$Shucked_weight.3)\nsummary(simple.linear.fit$Shucked_weight.log)\nsummary(simple.linear.fit$Viscera_weight.log)\nsummary(simple.linear.fit$Shell_weight.3)\nsummary(simple.linear.fit$Shell_weight.log)\n\nMSE = matrix(nrow = ncol(abalone), ncol = 2)\ncolnames(MSE) = c(\"train\", \"test\")\nrownames(MSE) = names(abalone)\nfor (tt in colnames(MSE)) {\n  for (i in rownames(MSE)) {\n    MSE[i, tt] = mean(sapply(\n      1:5, \n      run_lm_fold, \n      model = Rings~eval(parse(text = i)), \n      tt = tt\n    ))\n  }\n}\n\n\n# Plot\nmyData = melt.data.frame(\n  abalone[abalone$Height<0.3,],\n  id.vars=c(\"Sex\", names(abalone)[Y.vars])\n)\n\nselected.fields = c(\n  \"Whole_weight\",\n  \"log(Whole_weight)\",\n  \"Shucked_weight\",\n  \"log(Shucked_weight)\",\n  \"Viscera_weight\",\n  \"log(Viscera_weight)\",\n  \"Shell_weight\",\n  \"(Shell_weight)^(1/3)\"\n)\nnames(selected.fields) = c(\n  \"Whole_weight\",\n  \"Whole_weight.log\",\n  \"Shucked_weight\",\n  \"Shucked_weight.log\",\n  \"Viscera_weight\",\n  \"Viscera_weight.log\",\n  \"Shell_weight\",\n  \"Shell_weight.3\"\n)\n\nggplot(subset(myData, variable %in% names(selected.fields)), aes(x = value, y = Rings)) + \n  geom_jitter(alpha = 0.03) + geom_smooth(method = lm) +\n  facet_wrap( ~ variable, ncol = 2, scales = \"free\", labeller = as_labeller(selected.fields)) + \n  xlab(\"\")\n\n# Linear regression using multiple variables\n## Only linear models\nabalone = abalone[,1:9]\n\nmyFit = lm(Rings~., abalone)\nsummary(myFit)\n\nmyModel = Rings ~ \n  Diameter + \n  Height + \n  Whole_weight + \n  Shucked_weight + \n  Viscera_weight + \n  Shell_weight\nmyFit = lm(myModel, abalone)\nsummary(myFit)\n\n\nMSE = matrix(nrow = 1, ncol = 2)\ncolnames(MSE) = c(\"train\", \"test\")\nfor (tt in colnames(MSE)) {\n  MSE[1, tt] = mean(sapply(\n    1:5, \n    run_lm_fold, \n    model = myModel, \n    tt = tt\n  ))\n}\n\n# Add non-linearities\nabalone = add.non.linearities(abalone)\n\nmyModel = Rings ~\n  Length +\n  Height + \n  Whole_weight.log +\n  Shucked_weight.log +\n  Viscera_weight.log +\n  Shell_weight.3\nmyFit = lm(Rings~., abalone)\nsummary(myFit)\n\nmyFit = lm(myModel, abalone)\nsummary(myFit)\n\nMSE = matrix(nrow = 1, ncol = 2)\ncolnames(MSE) = c(\"train\", \"test\")\nfor (tt in colnames(MSE)) {\n  MSE[1, tt] = mean(sapply(\n    1:5, \n    run_lm_fold, \n    model = myModel, \n    tt = tt\n  ))\n}\n\nmyModel = Rings ~ \n  poly(Length, 2) +\n  poly(Height, 2) + \n  poly(Whole_weight, 2) +\n  poly(Shucked_weight, 2) +\n  poly(Viscera_weight, 2) +\n  poly(Shell_weight, 2)\nmyFit = lm(myModel, abalone)\nsummary(myFit)\n\nMSE = matrix(nrow = 1, ncol = 2)\ncolnames(MSE) = c(\"train\", \"test\")\nfor (tt in colnames(MSE)) {\n  MSE[1, tt] = mean(sapply(\n    1:5, \n    run_lm_fold, \n    model = myModel,\n    tt = tt\n  ))\n}\n\n# Add interactions\nmyModel = Rings ~ \n  Length +\n  Height +\n  Whole_weight.log *\n  Shucked_weight.log *\n  Viscera_weight *\n  Shell_weight.3\n\nmyFit = lm(myModel, abalone)\nsummary(myFit)\n\nMSE = matrix(nrow = 1, ncol = 2)\ncolnames(MSE) = c(\"train\", \"test\")\nfor (tt in colnames(MSE)) {\n  MSE[1, tt] = mean(sapply(1:5, run_lm_fold, model = myModel, tt = tt))\n}\n\n",
    "created" : 1502119376707.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3908747823",
    "id" : "8EA30116",
    "lastKnownWriteTime" : 1502886054,
    "last_content_update" : 1502886054,
    "path" : "/home/cristian10/workspace/master/icd/final/src/regression/linear-regression.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}